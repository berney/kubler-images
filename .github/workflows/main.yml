name: Kubler Build
on:
  push:
    branches:
      - main
  workflow_dispatch:

# Jobs run in parallel
# Jobs are independent with separate file systems, IP addresses, etc.
jobs:
  kubler:
    runs-on: ubuntu-latest
    steps:
      - run: echo "üéâ The job was automatically triggered by a ${{ github.event_name }} event."
      - run: echo "üêß This job is now running on a ${{ runner.os }} server hosted by GitHub!"
      - run: echo "üîé The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."

      - name: Check out repository code
        uses: actions/checkout@v4

      - run: echo "üí° The ${{ github.repository }} repository has been cloned to the runner."
      - run: echo "üñ•Ô∏è The workflow is now ready to test your code on the runner."

      - name: List files in the repository
        run: |
          ls ${{ github.workspace }}

      - name: üîé Inspect Runner
        run: |
          df -h
          free -m
          bash --version
          docker version
          docker info
          pwd
          echo $PATH
          type goss || true

      - name: Install goss
        if: ${{ false }}
        run: |
          # I do build my own goss, but chicken and the egg problem
          curl -sSLO https://github.com/goss-org/goss/releases/latest/download/goss-linux-amd64
          chmod +x goss-linux-amd64
          mv goss-linux-amd64 /usr/local/bin/goss
          type goss
          goss --version
          # Berney: I can't use upstream's `dgoss` as is because it assumes containers are daemon like
          # and doesn't cater to tool like images that do a job and exit - e.g. figlet.
          # So I have modified `dgoss` to suit my needs
          #curl -sSLO https://raw.githubusercontent.com/goss-org/goss/master/extras/dgoss/dgoss
          #chmod +x dgoss
          #mv dgoss /usr/local/bin/
          #type dgoss

      - name: Install goss from berne/goss
        #if: ${{ false }}
        run: |
          # This is a modified goss
          docker pull berne/goss
          docker create --name goss berne/goss
          docker cp goss:/bin/goss /usr/local/bin/
          docker rm goss
          type goss
          goss --version

      - name: Update Docker Engine
        # Disable
        if: ${{ false }}
        run: |
          docker version
          docker info
          # Remove old packages
          for pkg in docker.io docker-doc docker-compose podman-docker containerd runc; do sudo apt-get remove $pkg || true; done
          sudo apt-get update
          sudo apt-get install ca-certificates curl gnupg
          ls -ld /etc/apt/keyrings || true
          ls -l /etc/apt/keyrings/docker.gpg || true
          sudo install -m 0755 -d /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
          sudo chmod a+r /etc/apt/keyrings/docker.gpg
          ls -ld /etc/apt/sources.list.d || true
          ls -l /etc/apt/sources.list.d/ || true
          ls -l /etc/apt/sources.list.d/docker.list || true
          echo \
            "deb [arch="$(dpkg --print-architecture)" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
            "$(. /etc/os-release && echo "$VERSION_CODENAME")" stable" | \
            sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          cat /etc/apt/sources.list.d/docker.list
          sudo apt-get update
          sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
          systemctl status docker
          sudo systemctl start docker
          docker version
          docker info
          docker run --rm hello-world

      - name: üë∑ Install Kubler
        run: |
          cd .. || exit 1

          ## Install from tarball
          #
          #curl -L https://github.com/edannenberg/kubler/archive/master.tar.gz | tar xz
          #ls -ld kubler-master
          #mv kubler-master kubler
          #ls -l kubler/bin
          #echo "$(pwd)/kubler/bin" >> $GITHUB_PATH

          ## Install from Git
          #
          git clone https://github.com/berney/kubler.git
          cd kubler || exit 1
          # Using my branch to pick-up fixes until PRs are merged
          #git checkout f-berne
          git checkout f-experiment-buildx-bake
          git describe --all --long --dirty
          #git checkout f-berne-bake
          ls -l bin
          echo "$(pwd)/bin" >> $GITHUB_PATH

      - name: üë∑ Kubler Version
        run: |
          export TERM
          kubler --help

      - name: üë∑ Kubler Inspect Terminal
        run: |
          echo "TERM=$TERM"
          echo $PATH
          pwd
          env
          # test term colors
          kubler dep-graph xxx || true
          echo "export TERM"
          export TERM
          kubler dep-graph xxx || true
          echo "export TERM=dumb"
          export TERM
          export TERM=dumb
          kubler dep-graph xxx || true
          echo "export TERM=xterm"
          export TERM=xterm
          kubler dep-graph xxx || true

      # Cache Versions are based off key and path, so differnt path's can use same key
      #
      # Caches are immutable, so need unique key to create a new cache
      # `restore-keys` provides a list to restore a cache when key doesn't match
      # If there's no exact match, the most recent cache that partially matches will be used
      #
      - name: Cache Kubler Downloads
        uses: actions/cache@v4
        with:
          path: ~/.kubler/downloads/
          key: kubler-${{ github.sha }}
          restore-keys: |
            kubler-

      - name: Cache Kubler Gentoo Distfiles
        uses: actions/cache@v4
        with:
          path: ~/.kubler/distfiles/
          key: kubler-${{ github.sha }}
          restore-keys: |
            kubler-

      - name: Cache Kubler Gentoo Packages
        uses: actions/cache@v4
        with:
          path: ~/.kubler/packages/
          key: kubler-${{ github.sha }}
          restore-keys: |
            kubler-

      - name: Set up QEMU
        id: qemu
        uses: docker/setup-qemu-action@v3
        with:
          image: tonistiigi/binfmt:latest
          platforms: all

      - name: üêã Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v3
        with:
          # This breaks kubler https://github.com/edannenberg/kubler/issues/215
          # Sets up `docker build` command as an alias to `docker buildx` (default `false`)
          install: true

      - name: üêã Inspect builder
        run: |
          echo "Name:      ${{ steps.buildx.outputs.name }}"
          echo "Endpoint:  ${{ steps.buildx.outputs.endpoint }}"
          echo "Status:    ${{ steps.buildx.outputs.status }}"
          echo "Flags:     ${{ steps.buildx.outputs.flags }}"
          echo "Platforms: ${{ steps.buildx.outputs.platforms }}"

      - name: üêã Docker Login
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
          # this is the default, end of job will logout
          #logout: true

      - name: üêã Docker Buildx Inspect
        run: |
          docker version
          docker info
          docker buildx version
          docker buildx ls
          # `default` is the name of the normie docker builder
          docker buildx inspect default
          # The buildx builder is the default builder due to the `install: true` above
          docker buildx inspect "${{ steps.buildx.outputs.name }}"

      # When we use `docker buildx` and `docker bake` we want to be able to access images we built in prior steps
      # For this we need the containerd-snapshotter feature which is in beta
      - name: Docker Daemon Config - Enable Containerd Snapshotter
        run: |
          id -a
          ls -l /etc/docker/daemon.json
          # Old config
          jq . /etc/docker/daemon.json
          # First read old config before we clobber it
          CONFIG=$(jq '.features["containerd-snapshotter"] = true' /etc/docker/daemon.json)
          # Write new config - sudo tee to write to root owned file
          echo "$CONFIG" | sudo tee /etc/docker/daemon.json
          jq . /etc/docker/daemon.json
          systemctl status docker
          sudo systemctl restart docker
          systemctl status docker
          docker run --rm hello-world

      - name: üêã Docker Buildx Inspect Again
        run: |
          docker version
          docker info
          docker buildx version
          docker buildx ls
          # `default` is the name of the normie docker builder
          docker buildx inspect default
          # The buildx builder is the default builder due to the `install: true` above
          docker buildx inspect "${{ steps.buildx.outputs.name }}"

      - name: üë∑ Update Kubler (kubler-images, Gentoo Stage3)
        run: |
          export TERM
          ls -la ~/.kubler || true
          ls -la ~/.kubler/namespaces || true
          ls -la ~/.kubler/namespaces/kubler || true
          kubler update
          ls -la ~/.kubler || true
          ls -la ~/.kubler/namespaces || true
          ls -la ~/.kubler/namespaces/kubler || true

      - name: üë∑ Inspect Kubler Images
        run: |
          cd ~/.kubler/namespaces/kubler/ || exit 1
          git remote -v
          git status
          git ls-files -o
          git diff

      - name: üë∑ Get STAGE3_DATE
        run: |
          cd ~/.kubler/namespaces/kubler/ || exit 1
          grep '^STAGE3_DATE=' builder/bob/build.conf
          grep '^STAGE3_DATE=' builder/bob-musl/build.conf
          bob=$(sed -n "s/^STAGE3_DATE='\(202[34][01][0-9]\{3\}T[0-9]\{6\}Z\)'$/\\1/p" builder/bob/build.conf)
          bob_musl=$(sed -n "s/^STAGE3_DATE='\(202[34][01][0-9]\{3\}T[0-9]\{6\}Z\)'$/\\1/p" builder/bob-musl/build.conf)
          if [[ ("$bob" != "$bob_musl") ]]; then
            echo "WARNING: bob and bob-musl have different STAGE3_DATE"
          fi
          echo "BOB_STAGE3_DATE=$bob" >> $GITHUB_ENV
          echo "BOB_MUSL_STAGE3_DATE=$bob_musl" >> $GITHUB_ENV

      - name: üë∑ Fix Kubler Images bob-musl
        # Disable
        if: ${{ false }}
        run: |
          cd ~/.kubler/namespaces/kubler/ || exit 1
          git remote -v
          git remote add berney https://github.com/berney/kubler-images-1.git
          git fetch --all
          git checkout berney/b-fix-util-linux-su-pam
          git diff master..HEAD

      - name: üë∑ Fix Kubler Images busybox
        # Disable
        if: ${{ false }}
        run: |
          cd ~/.kubler/namespaces/kubler/ || exit 1
          git remote -v
          git remote add berney https://github.com/berney/kubler-images-1.git
          git fetch --all
          git checkout berney/f-berne
          git diff master..HEAD

      - name: üë∑ Add Custom Kubler Command(s)
        run: |
          echo "Kubler Commands (OG)"
          pwd
          ls -l
          tree -a -C ../kubler
          ls -l ../kubler
          ls -l ../kubler/cmd
          echo "Custom Kubler Commands"
          ls -l kubler/cmd
          rsync -avi kubler/cmd/* ../kubler/cmd/
          echo "Kubler Commands (now)"
          ls -l ../kubler/cmd

      - name: üîë Get Gentoo Portage GPG Key
        run: |
          # For Portage signatures
          #
          # Fingerprint with spaces `gpg -k --fingerprint --with-subkey-fingerprints E1D6ABB63BFCFB4BA02FDF1CEC590EEAC9189250`:
          #
          # pub   rsa4096/DB6B8C1F96D8BF6D 2011-11-25 [C] [expires: 2023-07-01]
          #       Key fingerprint = DCD0 5B71 EAB9 4199 527F  44AC DB6B 8C1F 96D8 BF6D
          #       uid                 [ unknown] Gentoo ebuild repository signing key (Automated Signing Key) <infrastructure@gentoo.org>
          #       uid                 [ unknown] Gentoo Portage Snapshot Signing Key (Automated Signing Key)
          #       sub   rsa4096/EC590EEAC9189250 2011-11-25 [S] [expires: 2023-07-01]
          #             Key fingerprint = E1D6 ABB6 3BFC FB4B A02F  DF1C EC59 0EEA C918 9250
          #
          # Fingerprint longkeyid no spaces `gpg -k --with-subkey-fingerprints E1D6ABB63BFCFB4BA02FDF1CEC590EEAC9189250`:
          #
          # pub   rsa4096/DB6B8C1F96D8BF6D 2011-11-25 [C] [expires: 2023-07-01]
          #       DCD05B71EAB94199527F44ACDB6B8C1F96D8BF6D
          #       uid                 [ unknown] Gentoo ebuild repository signing key (Automated Signing Key) <infrastructure@gentoo.org>
          #       uid                 [ unknown] Gentoo Portage Snapshot Signing Key (Automated Signing Key)
          #       sub   rsa4096/EC590EEAC9189250 2011-11-25 [S] [expires: 2023-07-01]
          #             E1D6ABB63BFCFB4BA02FDF1CEC590EEAC9189250
          gpg --keyserver keys.gentoo.org --recv-keys DCD05B71EAB94199527F44ACDB6B8C1F96D8BF6D

          # For Stage3 signatures
          #
          # Fingerprint with spaces:
          #
          # pub   rsa4096/BB572E0E2D182910 2009-08-25 [SC] [expires: 2023-07-01]
          #       Key fingerprint = 13EB BDBE DE7A 1277 5DFD  B1BA BB57 2E0E 2D18 2910
          #       uid                 [ unknown] Gentoo Linux Release Engineering (Automated Weekly Release Key) <releng@gentoo.org>
          #       sub   rsa2048/2C44695DB9F6043D 2019-02-23 [S] [expires: 2023-07-01]
          #             Key fingerprint = 534E 4209 AB49 EEE1 C19D  9616 2C44 695D B9F6 043D
          #
          # Fingerprint no spaces:
          #
          # pub   rsa4096/BB572E0E2D182910 2009-08-25 [SC] [expires: 2023-07-01]
          #       13EBBDBEDE7A12775DFDB1BABB572E0E2D182910
          #       uid                 [ unknown] Gentoo Linux Release Engineering (Automated Weekly Release Key) <releng@gentoo.org>
          #       sub   rsa2048/2C44695DB9F6043D 2019-02-23 [S] [expires: 2023-07-01]
          #             534E4209AB49EEE1C19D96162C44695DB9F6043D
          #
          gpg --keyserver keys.gentoo.org --recv-keys 13EBBDBEDE7A12775DFDB1BABB572E0E2D182910

          gpg --list-public-keys
          gpg --list-public-keys --with-subkey-fingerprint
          gpg --list-public-keys --with-subkey-fingerprint --fingerprint
          # we just need the key, we don't need to sign/trust it

      - name: üë∑ Kubler Get Latest Portage Date
        run: |
          export TERM
          PORTAGE_DATE=$(kubler portage)
          echo "PORTAGE_DATE=$PORTAGE_DATE" >> $GITHUB_ENV

      - name: üë∑ Kubler Set kubler.conf PORTAGE_DATE
        run: |
          grep PORTAGE_DATE kubler.conf || true
          echo "PORTAGE_DATE=$PORTAGE_DATE" >> kubler.conf

      - name: üë∑ Kubler Set kubler.conf IMAGE_TAG
        run: |
          grep IMAGE_TAG kubler.conf || true
          echo "IMAGE_TAG=$PORTAGE_DATE" >> kubler.conf

      - name: üë∑ Check Kubler Downloads
        run: |
          ls -l ~/.kubler/downloads/portage* || true

      - name: üîë Check GPG
        run: |
          gpg --list-public-keys
          ls -l ~/.kubler/downloads/portage-"${PORTAGE_DATE}".* || true
          if [ -e ~/.kubler/downloads/portage-"${PORTAGE_DATE}".tar.xz.gpgsig ] && [ -e ~/.kubler/downloads/portage-"${PORTAGE_DATE}".tar.xz ]; then
            gpg --verify ~/.kubler/downloads/portage-"${PORTAGE_DATE}".tar.xz.gpgsig ~/.kubler/downloads/portage-"${PORTAGE_DATE}".tar.xz
          else
            echo "[!] No files to verify"
          fi

      - name: üêãüç≥ Docker Bake Kubler - images before baking
        run: |
          docker images

      - name: üêã Use docker buildx instance - before
        if: ${{ false }}
        run: |
          docker buildx ls

      - name: üêã Use docker buildx instance
        if: ${{ false }}
        run: |
          # the default docker builder instance can use local images as base images
          # but IIRC it cannot build multi-platform images
          # With the containerd snapshotter it should support multi-platform images
          # It does not support GHA Cache backend
          #
          # Still need this because of `kubler` behaviour with parent images in Dockerfiles.
          docker buildx use default

      - name: üêã Use docker buildx instance - after
        if: ${{ false }}
        run: |
          docker buildx ls

      - name: üêãüç≥ Docker Bake Kubler portage - set TMP_PORTAGE_IMAGE
        run: |
          set -eux
          TMP_PORTAGE_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/tmp/portage:"${PORTAGE_DATE}"
          echo "TMP_PORTAGE_IMAGE=$TMP_PORTAGE_IMAGE" >> $GITHUB_ENV

      - name: üêãüç≥ Docker Bake Kubler portage
        if: ${{ false }}
        run: |
          set -eux
          cd ../kubler/engine/docker/bob-portage || exit 1
          # Repeating `--set` adds to the array
          # - https://github.com/docker/buildx/issues/872
          # - Doing it this way results in one image (repository hash) with two tags
          # - doing separate `TAG=xxx docker buildx bake` commands results in two different images (repository hashes), with identical layers, and near identical metadata.
          #docker buildx bake --load --set kubler-portage.tags=kubler-gentoo/portage:latest --set kubler-portage.tags=kubler-gentoo/portage:$PORTAGE_DATE
          # XXX could `--push` here, but can't do both `--load` and `--push` at the same time.
          docker buildx bake --push --set kubler-portage.tags="${TMP_PORTAGE_IMAGE}"

      - name: Check env before exposing GitHub Runtime - grep
        run: |
          env | grep ^ACTIONS

      - name: Check env before exposing GitHub Runtime - full
        run: |
          env

      # Needed for bake-action to use GHA cache
      # XXX I think this may be a bit dangerous, exposing secrets to everything in the job
      - name: Expose GitHub Runtime
        #if: ${{ false }}
        uses: crazy-max/ghaction-github-runtime@v3

      - name: Check env after exposed GitHub Runtime - grep
        run: |
          env | grep ^ACTIONS

      - name: Check env after exposed GitHub Runtime - full
        run: |
          env

      - name: üêãüç≥ Docker Bake Kubler portage - list targets
        uses: docker/bake-action/subaction/list-targets@v4
        with:
          workdir: ../kubler/engine/docker/bob-portage

      - name: üêãüç≥ Docker Bake Kubler portage
        uses: docker/bake-action@v4
        with:
          workdir: ../kubler/engine/docker/bob-portage
          push: true
          set: |
            kubler-portage.tags=${{ env.TMP_PORTAGE_IMAGE }}
            kubler-portage.cache-from=type=gha,scope=portage
            kubler-portage.cache-to=type=gha,scope=portage

      - name: üêãüç≥ Docker Bake Kubler portage - test
        run: |
          set -eux
          docker run --rm "${TMP_PORTAGE_IMAGE}" grep TIMESTAMP /var/db/repos/gentoo/Manifest
          cd portage || exit 1
          GOSS_FILES_STRATEGY=cp ../dgoss run -w /goss --entrypoint /goss/goss "${TMP_PORTAGE_IMAGE}" validate --format documentation --color

      - name: üêãüç≥ Docker Bake Kubler portage - set PORTAGE_IMAGE
        run: |
          set -eux
          PORTAGE_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/portage:"${PORTAGE_DATE}"
          echo "PORTAGE_IMAGE=$PORTAGE_IMAGE" >> $GITHUB_ENV

      - name: üêãüç≥ Docker Bake Kubler portage - re-tag and push
        run: |
          set -eux
          # Simple `docker tag` fails with copying the SLSA attestation.
          #
          #docker tag "${TMP_PORTAGE_IMAGE}" "${PORTAGE_IMAGE}"
          #docker push "${PORTAGE_IMAGE}"
          #
          # To me this is a bug, considering it is docker tools default to add the attestation.
          #
          # Options are either:
          #   1. Use a more powerful tool:
          #       - skopeo - https://github.com/containers/skopeo
          #       - oras - https://github.com/oras-project/oras
          #       - crane - https://github.com/google/go-containerregistry (GGCR)
          #       - regctl - https://github.com/regclient/regclient
          #       - maybe img from containerd
          #   2. Rebuild againt with different name/tag, which should use the cache
          #
          # BTW skopeo inspect is povo mixing manifest and arch
          # `sudo apt-get update` is in previous step earlier - but that step is disabled
          sudo apt-get update
          sudo apt-get install -y skopeo
          # Without `--all` it won't copy the attestation, and will flatten the manifest
          skopeo copy --all docker://"${TMP_PORTAGE_IMAGE}" docker://"${PORTAGE_IMAGE}"

      - name: üêãüç≥ Docker Bake Kubler - images portage
        run: |
          docker images

      - name: üêãüç≥ Docker Bake Kubler stage3 - set ENV vars
        run: |
          set -eux
          # XXX Not the tags I'm setting here, and the BASE_TAG I use later probably have a disconnect
          STAGE3_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/stage3-amd64-hardened-nomultilib-openrc:"${PORTAGE_DATE}"
          echo "STAGE3_IMAGE=$STAGE3_IMAGE" >> $GITHUB_ENV
          STAGE3_MUSL_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/stage3-amd64-musl-hardened:"${PORTAGE_DATE}"
          echo "STAGE3_MUSL_IMAGE=$STAGE3_MUSL_IMAGE" >> $GITHUB_ENV

      - name: üêãüç≥ Docker Bake Kubler stage3
        if: ${{ false }}
        run: |
          set -eux
          cd ../kubler/engine/docker/bob-stage3 || exit 1
          # XXX There is a disconnect here between base image this would use and the tag we give it
          # Base image would be gentoo/stage3:musl-hardened (e.g. latest musl hardened image)
          # Could use `BASE_TAG=musl-hardened-20240102` (YYYYMMDD) to pin.
          # The stage3 date we tag it with might not be correct
          #
          # XXX These will default to using PORTAGE=gentoo/portage
          # But Kubler portage applies some patches
          # This is working because `kubler build` is mounting portage into container.
          # We could set `PORTAGE` to the kubler-portage image, so that the patches are embedded.
          BASE_TAG=hardened-nomultilib \
            PORTAGE=$PORTAGE_IMAGE \
            docker buildx bake \
              --push \
              --set gentoo-stage3.tags="${STAGE3_IMAGE}"
          BASE_TAG=musl-hardened \
            PORTAGE=$PORTAGE_IMAGE \
            docker buildx bake \
              --push \
              --set gentoo-stage3.tags="${STAGE3_MUSL_IMAGE}"

      - name: üêãüç≥ Docker Bake Kubler stage3 - list targets
        uses: docker/bake-action/subaction/list-targets@v4
        with:
          workdir: ../kubler/engine/docker/bob-stage3

      - name: üêãüç≥ Docker Bake Kubler stage3 - hardened-nomultilib
        uses: docker/bake-action@v4
        with:
          workdir: ../kubler/engine/docker/bob-stage3
          push: true
          # In the `docker-bake.hcl`
          # There is a variable `BASE_TAG` and `BASE_IMAGE`. `BASE_IMAGE` interpolates `BASE_TAG`i
          # These can be set with env vars when using `docker buildx bake` command
          # For the gentoo-stage3 target there's no `BASE_TAG` arg, only `BASE_IMAGE` which defaults to `BASE_IMAGE` var
          # When using bake-action we need to set the `BASE_IMAGE` arg, setting `BASE_TAG` arg won't do what we want.
          set: |
            gentoo-stage3.args.BASE_IMAGE=gentoo/stage3:hardened-nomultilib
            gentoo-stage3.args.PORTAGE=${{ env.PORTAGE_IMAGE }}
            gentoo-stage3.tags=${{ env.STAGE3_IMAGE }}
            gentoo-stage3.cache-from=type=gha,scope=portage
            gentoo-stage3.cache-from=type=gha,scope=stage3-hardened-nomultilib
            gentoo-stage3.cache-to=type=gha,scope=stage3-hardened-nomultilib

      - name: üêãüç≥ Docker Bake Kubler stage3 - musl-hardened
        uses: docker/bake-action@v4
        with:
          workdir: ../kubler/engine/docker/bob-stage3
          push: true
          # In the `docker-bake.hcl`
          # There is a variable `BASE_TAG` and `BASE_IMAGE`. `BASE_IMAGE` interpolates `BASE_TAG`i
          # These can be set with env vars when using `docker buildx bake` command
          # For the gentoo-stage3 target there's no `BASE_TAG` arg, only `BASE_IMAGE` which defaults to `BASE_IMAGE` var
          # When using bake-action we need to set the `BASE_IMAGE` arg, setting `BASE_TAG` arg won't do what we want.
          set: |
            gentoo-stage3.args.BASE_IMAGE=gentoo/stage3:musl-hardened
            gentoo-stage3.args.PORTAGE=${{ env.PORTAGE_IMAGE }}
            gentoo-stage3.tags=${{ env.STAGE3_MUSL_IMAGE }}
            gentoo-stage3.cache-from=type=gha,scope=portage
            gentoo-stage3.cache-from=type=gha,scope=stage3-musl-hardened
            gentoo-stage3.cache-to=type=gha,scope=stage3-musl-hardened


      - name: üêãüç≥ Docker Bake Kubler stage3 - test
        run: |
          set -eux
          docker run --rm "${STAGE3_IMAGE}" cat /etc/gentoo-release
          docker run --rm "${STAGE3_IMAGE}" sh -c "grep -E 'Latest|stage3' /latest-stage3*.txt"
          docker run --rm "${STAGE3_IMAGE}" eselect profile show
          docker run --rm "${STAGE3_MUSL_IMAGE}" cat /etc/gentoo-release
          docker run --rm "${STAGE3_MUSL_IMAGE}" sh -c "grep -E 'Latest|stage3' /latest-stage3*.txt"
          docker run --rm "${STAGE3_MUSL_IMAGE}" eselect profile show

      - name: üêãüç≥ Docker Bake Kubler - images stage3
        run: |
          docker images

      - name: üêãüç≥ Docker Bake Kubler bob-core - set ENV vars
        run: |
          set -eux
          BOB_CORE_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/bob-core:"${PORTAGE_DATE}"
          echo "BOB_CORE_IMAGE=$BOB_CORE_IMAGE" >> $GITHUB_ENV
          BOB_CORE_MUSL_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/bob-musl-core:"${PORTAGE_DATE}"
          echo "BOB_CORE_MUSL_IMAGE=$BOB_CORE_MUSL_IMAGE" >> $GITHUB_ENV

      - name: üêãüç≥ Docker Bake Kubler bob-core
        if: ${{ false }}
        run: |
          set -eux
          cd ../kubler/engine/docker/bob-core || exit 1
          BASE_IMAGE="${STAGE3_IMAGE}" \
            docker buildx bake \
              --push  \
              --set core.tags="${BOB_CORE_IMAGE}"
          DEF_CHOST=x86_64-gentoo-linux-musl \
            BASE_IMAGE="${STAGE3_MUSL_IMAGE}" \
            docker buildx bake \
              --push \
              --set core.tags="${BOB_CORE_MUSL_IMAGE}"

      - name: üêãüç≥ Docker Bake Kubler bob-core - list targets
        uses: docker/bake-action/subaction/list-targets@v4
        with:
          workdir: ../kubler/engine/docker/bob-core

      - name: üêãüç≥ Docker Bake Kubler bob-core
        uses: docker/bake-action@v4
        with:
          workdir: ../kubler/engine/docker/bob-core
          push: true
          set: |
            core.args.BASE_IMAGE=${{ env.STAGE3_IMAGE }}
            core.tags=${{ env.BOB_CORE_IMAGE }}
            core.cache-from=type=gha,scope=portage
            core.cache-from=type=gha,scope=stage3-hardened-nomultilib
            core.cache-from=type=gha,scope=bob-core
            core.cache-to=type=gha,scope=bob-core

      - name: üêãüç≥ Docker Bake Kubler bob-musl-core
        uses: docker/bake-action@v4
        with:
          workdir: ../kubler/engine/docker/bob-core
          push: true
          set: |
            core.args.DEF_CHOST=x86_64-gentoo-linux-musl
            core.args.BASE_IMAGE=${{ env.STAGE3_MUSL_IMAGE }}
            core.tags=${{ env.BOB_CORE_MUSL_IMAGE }}
            core.cache-from=type=gha,scope=portage
            core.cache-from=type=gha,scope=stage3-musl-hardened
            core.cache-from=type=gha,scope=bob-musl-core
            core.cache-to=type=gha,scope=bob-musl-core


      - name: üêãüç≥ Docker Bake Kubler bob-core - test
        run: |
          set -eux
          docker run --rm "${BOB_CORE_IMAGE}" cat /etc/gentoo-release
          docker run --rm "${BOB_CORE_IMAGE}" sh -c "grep -E 'Latest|stage3' /latest-stage3*.txt"
          docker run --rm "${BOB_CORE_IMAGE}" eselect profile show
          docker run --rm "${BOB_CORE_IMAGE}" ls -l /var/cache

      - name: üêãüç≥ Docker Bake Kubler bob-musl-core - test
        run: |
          set -eux
          docker run --rm "${BOB_CORE_MUSL_IMAGE}" cat /etc/gentoo-release
          docker run --rm "${BOB_CORE_MUSL_IMAGE}" sh -c "grep -E 'Latest|stage3' /latest-stage3*.txt"
          docker run --rm "${BOB_CORE_MUSL_IMAGE}" eselect profile show
          docker run --rm "${BOB_CORE_MUSL_IMAGE}" ls -l /var/cache

      - name: üêãüç≥ Docker Bake Kubler - images bob-core
        run: |
          docker images

      - name: üêã Docker Build kubler builder - bob - set ENV vars
        run: |
          set -eux
          BOB_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/bob:"${PORTAGE_DATE}"
          echo "BOB_IMAGE=$BOB_IMAGE" >> $GITHUB_ENV

      - name: üêã Docker Build kubler builder - bob
        if: ${{ false }}
        run: |
          set -eux
          # Build kubler builder outside of kubler with native Docker tools
          # So that we can use the buildkit docker-container driver that supports GHA caching
          cd builder/bob || exit 1
          # This dockerfile does similar to what kubler does to build a builder
          # Difference is kubler uses docker run and mounts volumes, and then commits the container as an image
          # We are building direct, so can't use volumes.
          # I am hoping caching makes up for that.
          docker buildx build \
            --push \
            -f Dockerfile.berney \
            --build-arg PARENT="${BOB_CORE_IMAGE}" \
            -t "${BOB_IMAGE}" \
            .

      - name: üêã Docker Build kubler builder - bob - list targets
        uses: docker/bake-action/subaction/list-targets@v4
        with:
          workdir: builder/bob

      - name: üêãüç≥ Docker Bake Kubler builder - bob
        uses: docker/bake-action@v4
        with:
          workdir: builder/bob
          push: true
          set: |
            bob.args.BASE_IMAGE=${{ env.BOB_CORE_IMAGE }}
            bob.tags=${{ env.BOB_IMAGE }}
            bob.cache-from=type=gha,scope=portage
            bob.cache-from=type=gha,scope=stage3-hardened-nomultilib
            bob.cache-from=type=gha,scope=bob-core
            bob.cache-from=type=gha,scope=bob
            bob.cache-to=type=gha,scope=bob

      - name: üêã Docker Build kubler builder - bob - test
        run: |
          set -eux
          docker run --rm "${BOB_IMAGE}" cat /etc/gentoo-release
          docker run --rm "${BOB_IMAGE}" sh -c "grep -E 'Latest|stage3' /latest-stage3*.txt"
          docker run --rm "${BOB_IMAGE}" eselect profile show
          docker run --rm "${BOB_IMAGE}" ls -l /var/cache
          docker run --rm "${BOB_IMAGE}" ls -l /var/cache/eix
          docker run --rm "${BOB_IMAGE}" eix --selected -c

      - name: üêã Docker Build kubler builder - bob-musl - set ENV vars
        run: |
          set -eux
          BOB_MUSL_IMAGE=ghcr.io/"${GITHUB_REPOSITORY}"/bob-musl:"${PORTAGE_DATE}"
          echo "BOB_MUSL_IMAGE=$BOB_MUSL_IMAGE" >> $GITHUB_ENV

      - name: üêã Docker Build kubler builder - bob-musl
        if: ${{ false }}
        run: |
          set -eux
          # Build kubler builder outside of kubler with native Docker tools
          # So that we can use the buildkit docker-container driver that supports GHA caching
          cd builder/bob-musl || exit 1
          # This dockerfile does similar to what kubler does to build a builder
          # Difference is kubler uses docker run and mounts volumes, and then commits the container as an image
          # We are building direct, so can't use volumes.
          # I am hoping caching makes up for that.
          docker buildx build \
            --push \
            -f Dockerfile.berney \
            --build-arg PARENT="${BOB_CORE_MUSL_IMAGE}" \
            -t "${BOB_MUSL_IMAGE}" \
            .

      - name: üêãüç≥ Docker Bake Kubler builder - bob-musl
        uses: docker/bake-action@v4
        with:
          workdir: builder/bob-musl
          push: true
          set: |
            bob-musl.args.BASE_IMAGE=${{ env.BOB_CORE_MUSL_IMAGE }}
            bob-musl.tags=${{ env.BOB_MUSL_IMAGE }}
            bob-musl.cache-from=type=gha,scope=portage
            bob-musl.cache-from=type=gha,scope=stage3-musl-hardened
            bob-musl.cache-from=type=gha,scope=bob-musl-core
            bob-musl.cache-from=type=gha,scope=bob-musl
            bob-musl.cache-to=type=gha,scope=bob-musl


      - name: üêã Docker Build kubler builder - bob-musl - test
        run: |
          set -eux
          docker run --rm "${BOB_MUSL_IMAGE}" cat /etc/gentoo-release
          docker run --rm "${BOB_MUSL_IMAGE}" sh -c "grep -E 'Latest|stage3' /latest-stage3*.txt"
          docker run --rm "${BOB_MUSL_IMAGE}" eselect profile show
          docker run --rm "${BOB_MUSL_IMAGE}" ls -l /var/cache
          docker run --rm "${BOB_MUSL_IMAGE}" ls -l /var/cache/eix
          docker run --rm "${BOB_MUSL_IMAGE}" eix --selected -c

      - name: üêãüç≥ Docker Images
        run: |
          docker images

      - name: üêãüç≥ Docker Tag Images for Kubler Compatability
        run: |
          docker tag "${PORTAGE_IMAGE}" kubler-gentoo/portage:latest
          docker tag "${BOB_CORE_MUSL_IMAGE}" kubler/bob-musl-core:"${PORTAGE_DATE}"
          docker tag "${BOB_CORE_IMAGE}" kubler/bob-core:"${PORTAGE_DATE}"
          # My bob-musl builder
          docker tag "${BOB_MUSL_IMAGE}" kubler/bob-musl:"${PORTAGE_DATE}"
          docker tag "${BOB_IMAGE}" kubler/bob:"${PORTAGE_DATE}"
          docker images

      - name: üêãüç≥ Docker Images
        run: |
          docker images

      - name: üë∑ Kubler Set kubler.conf DEFAULT_MUSL_BUILDER
        if: ${{ false }}
        run: |
          grep DEFAULT_MUSL_BUILDER kubler.conf || true
          echo "DEFAULT_MUSL_BUILDER=$BOB_MUSL_IMAGE" >> kubler.conf

      - name: üë∑ Portage Container - eix-update - Populate /var/cache/eix
        run: |
          set -u
          # Kubler building builders would use volume from portage container
          # and run `eix-update` which would populate /var/cache/eix.
          # But I'm building the builders directly with docker
          # Docker build doesn't support mounting volumes during builds
          # When using `kubler build` to build images with our builder,
          # the builds fail with this error:
          #
          #   cannot open database file /var/cache/eix/portage.eix for reading
          #
          # So this step will fix this to make kubler build for images happy.
          # kubler does `docker run`, but I think `docker create` is more idiomatic
          docker create --name kubler-gentoo-portage "${PORTAGE_IMAGE}" true
          docker run --rm --volumes-from kubler-gentoo-portage "${BOB_MUSL_IMAGE}" ls -l /var/cache
          docker run --rm --volumes-from kubler-gentoo-portage "${BOB_MUSL_IMAGE}" ls -l /var/cache/eix
          docker run --rm --volumes-from kubler-gentoo-portage "${BOB_MUSL_IMAGE}" eix-update
          docker run --rm --volumes-from kubler-gentoo-portage "${BOB_MUSL_IMAGE}" ls -l /var/cache
          docker run --rm --volumes-from kubler-gentoo-portage "${BOB_MUSL_IMAGE}" ls -l /var/cache/eix

      - name: üöß Build Images - berney/busybox
        #if: ${{ false }}
        id: busybox
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          # This is my copy with small changes
          kubler build -v busybox

      - name: üöß Build Images - kubler/busybox
        #if: ${{ false }}
        id: kubler-busybox
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v kubler/busybox

      #- name: üõë STOP HERE
      #  run: |
      #    false

      - name: üöß Build Images - kubler/glibc
        #if: ${{ false }}
        id: glibc
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v kubler/glibc

      - name: üöß Build Images - figlet
        #if: ${{ false }}
        id: figlet
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v figlet

      - name: Test Image - figlet
        id: test-figlet
        continue-on-error: true
        run: |
          cd images/figlet || false
          echo "kubler=test" >> $GITHUB_OUTPUT
          GOSS_FILES_STRATEGY=cp ../../dgoss run -w /goss --entrypoint /goss/goss kubler-images/figlet validate --format documentation --color

      - name: üöß Build Images - figlet-user
        #if: ${{ false }}
        id: figlet-user
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v figlet-user

      - name: Test Image - figlet-user
        id: test-figlet-user
        continue-on-error: true
        run: |
          cd images/figlet-user || false
          echo "kubler=test" >> $GITHUB_OUTPUT
          GOSS_FILES_STRATEGY=cp ../../dgoss run -w /goss --entrypoint /goss/goss kubler-images/figlet-user validate --format documentation --color

      - name: üöß Build Images - figlet-musl
        #if: ${{ false }}
        id: figlet-musl
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v figlet-musl

      - name: Test Image - figlet-musl
        id: test-figlet-musl
        continue-on-error: true
        run: |
          cd images/figlet-musl || false
          echo "kubler=test" >> $GITHUB_OUTPUT
          GOSS_FILES_STRATEGY=cp ../../dgoss run -w /goss --entrypoint /goss/goss kubler-images/figlet-musl validate --format documentation --color

      - name: üöß Build Images - figlet-musl-static
        #if: ${{ false }}
        id: figlet-musl-static
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v figlet-musl-static

      - name: Test Image - figlet-musl-static
        id: test-figlet-musl-static
        continue-on-error: true
        run: |
          cd images/figlet-musl-static || false
          echo "kubler=test" >> $GITHUB_OUTPUT
          GOSS_FILES_STRATEGY=cp ../../dgoss run -w /goss --entrypoint /goss/goss kubler-images/figlet-musl-static validate --format documentation --color

      - name: üöß Build Images - goss
        #if: ${{ false }}
        id: goss
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v goss

      - name: üöß Build Images - fd
        #if: ${{ false }}
        id: fd
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v fd

      - name: üöß Build Images - s6
        #if: ${{ false }}
        id: s6
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build -v s6

      - name: üöß Build Images - s6 - test
        #if: ${{ false }}
        id: s6-test
        continue-on-error: true
        run: |
          docker run --rm kubler-images/s6 s6-svscan -h
          # XXX Will need to push or something so derived images can use it

      - name: üöß Build Images - s6 - push
        #if: ${{ false }}
        id: s6-push
        continue-on-error: true
        run: |
          # The buildx docker-container driver can't pull from the local registry
          # So we need to push the image
          docker tag kubler-images/s6 ghcr.io/berney/kubler-images/s6
          docker push ghcr.io/berney/kubler-images/s6

      - name: üöß Build Images - s6-busybox
        #if: ${{ false }}
        id: s6-busybox
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          DOCKER_BUILD_OPTS="--load"\
          " --cache-from=type=gha,scope=s6-busybox"\
          " --cache-to=type=gha,scope=s6-busybox" \
          kubler build -v s6-busybox

      - name: üöß Build Images - s6-busybox - push
        #if: ${{ false }}
        id: s6-busybox-push
        continue-on-error: true
        run: |
          # The buildx docker-container driver can't pull from the local registry
          # So we need to push the image
          docker tag kubler-images/s6-busybox ghcr.io/berney/kubler-images/s6-busybox
          docker push ghcr.io/berney/kubler-images/s6-busybox

      # This is based off s6
      - name: üöß Build Images - coturn
        #if: ${{ false }}
        id: coturn
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          # To continue the string, no spaces between end quote,slash, EOL, or start of line
          # e.g. as a stream its `"alpha"\\\n" omega"\\\n"
          DOCKER_BUILD_OPTS="--load"\
          " --cache-from=type=gha,scope=coturn"\
          " --cache-to=type=gha,scope=coturn" \
            kubler build -v coturn

      - name: üöß Build Images - s6-coturn-busybox
        #if: ${{ false }}
        id: s6-coturn-busybox
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          DOCKER_BUILD_OPTS="--load"\
          " --cache-from=type=gha,scope=coturn"\
          " --cache-from=type=gha,scope=s6-busybox"\
          " --cache-from=type=gha,scope=s6-coturn-busybox"\
          " --cache-to=type=gha,scope=s6-coturn-busybox" \
            kubler build -v s6-coturn-busybox

      - name: üöß Build Images - nmap
        #if: ${{ false }}
        id: nmap
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          DOCKER_BUILD_OPTS="--load"\
          " --cache-from=type=gha,scope=nmap"\
          " --cache-to=type=gha,scope=nmap" \
            kubler build -v nmap

      - name: üöß Build Images - nmap-musl-static
        #if: ${{ false }}
        id: nmap-musl-static
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          DOCKER_BUILD_OPTS="--load"\
          " --cache-from=type=gha,scope=nmap-musl-static"\
          " --cache-to=type=gha,scope=nmap-musl-static" \
            kubler build -v nmap-musl-static

      - name: üöß Build Images - tmux
        #if: ${{ false }}
        id: tmux
        continue-on-error: true
        run: |
          echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          DOCKER_BUILD_OPTS="--load"\
          " --cache-from=type=gha,scope=tmux"\
          " --cache-to=type=gha,scope=tmux" \
            kubler build -v tmux

      - name: üöß Build Images - Everything excluding Problematic
        #if: ${{ false }}
        id: everything-exc-problematic
        continue-on-error: true
        run: |
          #echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build kubler-images -e kubler-images/nmap-musl-static

      - name: üöß Build Images - EVERYTHING
        if: ${{ false }}
        id: everything
        continue-on-error: true
        run: |
          #echo "kubler=build" >> $GITHUB_OUTPUT
          export TERM
          kubler build kubler-images

      - name: üîé Post Build Inspect
        env:
          # This will contain double-quotes, which `echo` would eat, breaking `jq`
          # https://stackoverflow.com/a/72955840
          STEPS: ${{ toJSON(steps) }}
        run: |
          docker images
          docker ps -a
          df -h
          git status
          git ls-files -o
          ls -ld ~/.kubler
          ls -la ~/.kubler
          ls -ld ~/.kubler/log
          ls -la ~/.kubler/log
          ls -l ~/.kubler/log/build.log || true
          cat ~/.kubler/log/build.log || true
          echo "== Steps"
          printf '%s\n' "$STEPS"
          echo "== Steps | jq"
          printf '%s\n' "$STEPS" | jq .
          echo "== Steps | jq expr"
          printf '%s\n' "$STEPS" | jq 'to_entries | map(select(.value.outputs.kubler == "build").key)'

      - name: üîé Sumarise Build Status
        env:
          # This will contain double-quotes, which `echo` would eat, breaking `jq`
          # https://stackoverflow.com/a/72955840
          STEPS: ${{ toJSON(steps) }}
        run: |
          echo "# Successful Build Steps"
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "build" and .outcome == "success").key | sub("^"; "* ")) | join("\n")'
          echo "# Failed Build Steps"
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "build" and .outcome != "success").key | sub("^"; "* ")) | join("\n")'

          echo "# Successful Build Steps" >> $GITHUB_STEP_SUMMARY
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "build" and .outcome == "success").key | sub("^"; "* ")) | join("\n")' >> $GITHUB_STEP_SUMMARY
          echo "# Failed Build Steps" >> $GITHUB_STEP_SUMMARY
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "build" and .outcome != "success").key | sub("^"; "* ")) | join("\n")' >> $GITHUB_STEP_SUMMARY

      - name: üîé Sumarise Test Status
        env:
          # This will contain double-quotes, which `echo` would eat, breaking `jq`
          # https://stackoverflow.com/a/72955840
          STEPS: ${{ toJSON(steps) }}
        run: |
          echo "# Successful Test Steps"
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "test" and .outcome == "success").key | sub("^"; "* ")) | join("\n")'
          echo "# Failed Test Steps"
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "test" and .outcome != "success").key | sub("^"; "* ")) | join("\n")'

          echo "# Successful Test Steps" >> $GITHUB_STEP_SUMMARY
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "test" and .outcome == "success").key | sub("^"; "* ")) | join("\n")' >> $GITHUB_STEP_SUMMARY
          echo "# Failed Test Steps" >> $GITHUB_STEP_SUMMARY
          printf '%s\n' "$STEPS" | jq -r 'to_entries | map(select(.value | .outputs.kubler == "test" and .outcome != "success").key | sub("^"; "* ")) | join("\n")' >> $GITHUB_STEP_SUMMARY

      - run: echo "üçè This job's status is ${{ job.status }}."
